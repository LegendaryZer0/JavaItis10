# 11. Классы

* Аналог структур в C/C++.

* Объект - экземпляр класса. Вы никогда не имеете прямого доступа к объекту, только через указатель (объектную переменную).

## 11.00 Более предметно

* Парадигма программирования - способ организации вычислений и прочих процессов внутри кода, а также тип мышления разработка при решении задачи.

* Процедурное программирование - данная парадигма подразумевает наличие структур и процедур/функций для решения какой либо задачи. Характерно для C/Pascal. `ПРОГРММА = АЛГОРИТМ + СТРУКТУРА ДАННЫХ`

* Логическое программирование - программа состоит из логических предикатов, функции которые возвращают да/нет. Характерна для Prolog.

* Функциональное программирование - все есть функция. Характерно для Lisp/Erlang/Go/Haskel

* Объектно-ориентированное программирование (ООП) - программа состоит из объектов, которые посылают друг другу сообщения.

## 11.01 ООП

* Класс - абстрактный тип данных, пользовательский тип, определяемый программистом исходя из модели абстракции. Подразумевается, что на основе классы создаются объекты.

* Абстракция - первый принцип ООП, набор значимых характеристик в контексте решаемой задачи.

* Важный момент:

```
go(marsel, 25);
```

* В ООП всегда есть источник действия, и иногда правильнее, чтобы источником такого действия был сам объект:

```
marsel.go(30);
```

## 11.02 Структура класса в Java

```
class ИМЯ_КЛАССА {

	// поля (fields)
	ТИП_ДАННЫХ ИМЯ_ПОЛЯ;
	ТИП_ДАННЫХ ИМЯ_ПОЛЯ;
	ТИП_ДАННЫХ ИМЯ_ПОЛЯ;
	ТИП_ДАННЫХ ИМЯ_ПОЛЯ;
	...

	// конструкторы (constructors)
	ИМЯ_КЛАССА(ФОРМАЛЬНЫЕ_ПАРАМЕТРЫ) {
		...
	}

	ИМЯ_КЛАССА(ФОРМАЛЬНЫЕ_ПАРАМЕТРЫ) {
		...
	}

	// методы (methods)
	ТИП_ДАННЫХ ИМЯ_МЕТОДА(ФОРМАЛЬНЫЕ ПАРАМЕТРЫ) {
		ТЕЛО_МЕТОДА;
	}

	ТИП_ДАННЫХ ИМЯ_МЕТОДА(ФОРМАЛЬНЫЕ ПАРАМЕТРЫ) {
		ТЕЛО_МЕТОДА;
	}
	...
}
```

* Метод - функция/процедура, объявленная внутри класса.

* Объект - экземпляр класса. Каждый объект обладает состоянием и поведением. Поведение - методы. Состояние - характеристики объекта, у каждого объекта они свои - поля. Конкретные значения полей каждого объекта определяют его состояние.

## 11.02 Создание объектов

* Создание объекта - это процесс выделения памяти для объекта, задание начальных характеристик этому объекту (инициализация) и присваивание указателя на этот объект объектной переменной.

```
НазваниеКласса имяПеременной = new НазваниеКласса()
```

* Создается объектная переменная 

* `new` - оператор выделения памяти, по факту создает объект

* `НазваниеКласса()` - конструктор.

* `=` - присваивание.

* Конструктор - набор инструкций (специальный метод - но это неверно). Выполняет инициализацию полей объекта (задает начальные значения полям). Если конструктор не был определен для класса, то его автоматически создает Java. При этом такой конструктор не содержит ничего, и называется "конструктором по умолчанию".

* Вы можете описать свой конструктор - тогда, конструктор по умолчанию не будет создан.

* Вы можете перегрузить конструктор - то есть объявить консукторы с разной сигнатурой (разными формальными параметрами).

* Можно выделить следующие типы конструкторов - по умолчанию, пустой, с параметрами, копирования.

* `this` - объектная переменная, которая находится внутри объекта и содержит ссылку на этот самый объект.

```
_____________
|height = 10|<------ (rectangle1)
|width = 15 |
|this----------
|___________| |
     ^        |
     |        |
     _________|
```

## 11.03 Инкапсуляция

* Инкапсуляция (в капсуле) - объект - это "капсула", внутри которой описывается как поведение, так и состояние. В отличие от структур в C/C++, где описывается ТОЛЬКО состояние. 

* Первое определение инкапсуляции - возможность объединения алгоритмов и структур данных в одной сущности - класса, и на основе класса создавать объект, обладающий состоянием и поведением.

* Второе определение инкапсуляции - возможность закрытия внутренней структуры данных, с целью поддержания более "корректного" кода. То есть мы ограничиваем возможности по использованию наших классов.

* Если не "защищать" внутреннюю структуру объекта, то возможны ситуации нарушения семантической целостности объекта. Следовательно, необходимо реализовать "защиту" внутренней структуры и разрешать производить только корректные измнения состояния объекта.

* В Java это достигается засчет использования модификаторов доступа, обеспечивающих различный уровень доступа.

* `private` - модификатор доступа, который закрывает возможность работы с членом класса вне этого класса. Данный модификатор обеспечивает уровень доступа "закрытый".

* Но, что делать, если мы все-таки хотим работать с полем, но обеспечить целостность данных внутри поля? Используем - методы доступа.

* Методы доступа - не являются синтаксической и обязательной единицей в Java. Они просто признак качественного ООП кода. Методы доступа позволяют обеспечить контролируемый доступ над полем.

* Выделяют методы доступа - геттеры и сеттеры.

* Геттеры имеют вид:

```
public ТИП_ПОЛЯ getНазваниеПоля() {
	return названиеПоля;
}
```

* Геттеры позволяют прочитать значение.

* Сеттеры имеют вид:

```
public void setИмяПоля(ТИП_ПОЛЯ имяПоля) {
	// тело сеттера
}
```

* `public` - модификатор доступа, позволяющий работать с классом в любом участке кода, к которому подключен данный класс. Обеспечивает уровень доступа "Открытый"

* Принято, помечать все поля `private`, все методы доступа `public`, все методы, предназначенные для внешнего использования - `public`, все методы, предназначенные для внутреннего использования - `private`.

* Если модификатор не указан, то член класса или конструктор доступны внутри данного пакета. Уровень доступа - пакетны (package internal).

## 11.04 Статические члены класса

* Члены класса (поля, методы, константы) помеченные модификатором static.

* Инициализаторы (конструкторы), но объявленные иначе.

* Статические поля - поля, глобальные для всех объектов данного класса. То есть если в одном объекте меняется значение этого поля, то оно меняется разом у всех объектов. (Правильнее - такое поле только одно, и оно доступно всем объектам).

* Со статическими полями можно (нужно) работать только через класс.

* В статическом инициализаторе можно работать ТОЛЬКО со СТАТИЧЕСКИМИ ПЕРЕМЕННЫМИ.

* Когда нужны статические переменные? - когда необходимо иметь какой-либо глобальный контекст для объектов, например - направление ветра, в программировании - "подключение к базе данных".

* Статические константы - если объявляете константу, то всегда делайте ее статической.

* Статические методы - методы, относящиеся к классу, их можно вызывать непосредственно из класса. 

* Удобно использовать тогда, когда поведение такого метода не завязано на конкретном объекте, а является поведением предметной области.

* Статически метод может работать со статическими полями и методами, но не может работать с нестатическими полями и методами.

## 11.05 Отношения между классами

* Агрегирование - связь между двумя объектами, построенная таким образом, что один объект содержит поле-ссылку на другой объект.

* Наследование - третий принцип ООП.

- Позволяет избежать дублирования кода
- Построить правильную иерархию классов
- Служит опорой для полиморфизма
- Причина ненависти к ООП

* `extends` - ключевое слово, показывающее, что один класс является рашсирением другого класса.

* `A extends B` - класс А называется `классом-потомком`, а класс B - `классом-предком`.

* Если в классе-предке какой-либо член класса объявлен с модификатором `private`, то он не будет доступен в потомке.

* `protected` - модификатор доступа, обеспечивающий уровень доступа `защищенный`, член класса будет доступен для потомков и для всех классов внутри данного пакета.	

* `super` -  если употребляется без скобок, то это ссылка на объект класса-предка. Если скобки - то это вызов конструктора предка.

![000](https://raw.githubusercontent.com/MarselSidikov/JavaItis10/master/Themes/images/004.png)

* Потомок - всегда расширяет предка, но при этом является более специализированным классом. То есть потенциально предок всегда больше, чем потомок. То есть класс-потомок это частный случай класса-предка.

* Всегда нужно соблюдать правило, что экземпляр потомка так же является эклемпляром предка.

* В классе-потомке можно заново написать реализацию метода, который есть в классе предке (используя ту же сигнатуру, но разное тело). Такие методы назваются `переопределенными`

* В объектную переменную класса-предка можно положить значение, на которое указывает объектная переменная класса-потомка.

```

Player marsel -> [Player, "Марсель"]

UpgradedPlayer nadir -> [UpgradedPlayer, "Надир", 10 пуль]

МОЖНО ДЕЛАТЬ ТАК:

Player player -> [UpgradedPlayer, "Надир", 10 пуль]
```

* Восходящее преобразование - механизм, позволяющий объектной переменной класса предка указывать на объект класса потомка. Восходящее преобразование относится к классу неявных преобразований.

* Полиморфизм - возможность работы с объектами разных типов таким образом, будто они принадлежат одному типу. Достигается засчет наследования и восходящего преобразования.

* В случае, если мы гарантированно знаем, что в объектной переменной лежит объект потомка, то можно воспользоваться нисходящим преобразованием. Данное преобразование относится к классу явных преобразований.

* Бывают ситуации, когда нет необходимости (и семантической обоснованности) создавать экземпляры каких-либо классов. В таких ситуациях классы помечают модификатором `abstract`. Данный модификатор блокирует возможность создания объектов данного класса. Объектные переменные создавать можно.

* Если в данном классе нет необходимости (и семантической) обоснованности создавать тело метода, его можно пометить как `abstract`.

* Если в классе есть хотя бы один абстрактный метод, то весь класс должен быть помечен как `abstract`.

* Каждый класс-потомок обязуется реализовать абстрактный метод предка, иначе сам класс потомок тоже должен быть помечен как `abstract`.

* Множественное наследование - наличие у одного класса более одного предка. В Java - запрещено.

* Интерфейс в Java - это класс, не имеющий полей, но имеющий ТОЛЬКО абстрактные методы. Таким образом, интерфейсы описывают некоторое поведение, которым должен обладать какой-либо класс, имплементирующий (реализующий) данный интерфейс.

* От классов можно создавать как объектные переменные, так и объекты. От интерфейсов и абстрактных классов - только объектные переменные.

* Интерфейсы и абстрактные классы позволяют реализовать определенный каркас, в рамках которого нужно организовывать работу программы.

## 11.06 Вложенные и внутренние классы

* Вложенные классы - это классы, которые объявлены внутри другого класса.

* Вложенные классы делятся на две группы -> статические вложенные (вложенные), нестатические вложенные (внутренними).

* Статические вложенные классы загружаются в систему вместе с основным классом и не имеют доступа к полям данного класса.

* Внутренние классы имеют доступ к полям текущего объекта.

* Статические вложенные классы применяют, когда нет необходимости связывать объекты внутреннего класса и обрамляющего класса, например (Node в LinkedList, Builder в классе-модели и т.д.). Такие классы просто отражают семантику предметной области.

* Внутренние классы применяют, когда необходимо связать объекты обрамляющего класса и внутреннего.

## 11.07 Анонимные классы

* Анонимные классы - это классы, которые нигде не описаны в явном виде.

* По своей сути стандартными методами вы можете создать один экземпляр такого класса.

* Описание таких классов возможно внутри какого либо метода или внутри класса.

* Анонимные классы можно создавать на основе абстрактных классов и интерфейсов.

* Хорошей практикой считается использование интерфейсов с одним методом. Такие интерфейсы позволяют инкапсулировать какую-либо функцию и передать ее в качестве аргумента.

* Интерфейс, в котором содержится только один метод называется функциональным. На основе таких интерфейсов можно создавать не только анонимные классы, но и лямбда выражения.






