# 11. Классы

* Аналог структур в C/C++.

* Объект - экземпляр класса. Вы никогда не имеете прямого доступа к объекту, только через указатель (объектную переменную).

## 11.00 Более предметно

* Парадигма программирования - способ организации вычислений и прочих процессов внутри кода, а также тип мышления разработка при решении задачи.

* Процедурное программирование - данная парадигма подразумевает наличие структур и процедур/функций для решения какой либо задачи. Характерно для C/Pascal. `ПРОГРММА = АЛГОРИТМ + СТРУКТУРА ДАННЫХ`

* Логическое программирование - программа состоит из логических предикатов, функции которые возвращают да/нет. Характерна для Prolog.

* Функциональное программирование - все есть функция. Характерно для Lisp/Erlang/Go/Haskel

* Объектно-ориентированное программирование (ООП) - программа состоит из объектов, которые посылают друг другу сообщения.

## 11.01 ООП

* Класс - абстрактный тип данных, пользовательский тип, определяемый программистом исходя из модели абстракции. Подразумевается, что на основе классы создаются объекты.

* Абстракция - первый принцип ООП, набор значимых характеристик в контексте решаемой задачи.

* Важный момент:

```
go(marsel, 25);
```

* В ООП всегда есть источник действия, и иногда правильнее, чтобы источником такого действия был сам объект:

```
marsel.go(30);
```

## 11.02 Структура класса в Java

```
class ИМЯ_КЛАССА {

	// поля (fields)
	ТИП_ДАННЫХ ИМЯ_ПОЛЯ;
	ТИП_ДАННЫХ ИМЯ_ПОЛЯ;
	ТИП_ДАННЫХ ИМЯ_ПОЛЯ;
	ТИП_ДАННЫХ ИМЯ_ПОЛЯ;
	...

	// конструкторы (constructors)
	ИМЯ_КЛАССА(ФОРМАЛЬНЫЕ_ПАРАМЕТРЫ) {
		...
	}

	ИМЯ_КЛАССА(ФОРМАЛЬНЫЕ_ПАРАМЕТРЫ) {
		...
	}

	// методы (methods)
	ТИП_ДАННЫХ ИМЯ_МЕТОДА(ФОРМАЛЬНЫЕ ПАРАМЕТРЫ) {
		ТЕЛО_МЕТОДА;
	}

	ТИП_ДАННЫХ ИМЯ_МЕТОДА(ФОРМАЛЬНЫЕ ПАРАМЕТРЫ) {
		ТЕЛО_МЕТОДА;
	}
	...
}
```

* Метод - функция/процедура, объявленная внутри класса.

* Объект - экземпляр класса. Каждый объект обладает состоянием и поведением. Поведение - методы. Состояние - характеристики объекта, у каждого объекта они свои - поля. Конкретные значения полей каждого объекта определяют его состояние.

## 11.02 Создание объектов

* Создание объекта - это процесс выделения памяти для объекта, задание начальных характеристик этому объекту (инициализация) и присваивание указателя на этот объект объектной переменной.

```
НазваниеКласса имяПеременной = new НазваниеКласса()
```

* Создается объектная переменная 

* `new` - оператор выделения памяти, по факту создает объект

* `НазваниеКласса()` - конструктор.

* `=` - присваивание.

* Конструктор - набор инструкций (специальный метод - но это неверно). Выполняет инициализацию полей объекта (задает начальные значения полям). Если конструктор не был определен для класса, то его автоматически создает Java. При этом такой конструктор не содержит ничего, и называется "конструктором по умолчанию".

* Вы можете описать свой конструктор - тогда, конструктор по умолчанию не будет создан.

* Вы можете перегрузить конструктор - то есть объявить консукторы с разной сигнатурой (разными формальными параметрами).

* Можно выделить следующие типы конструкторов - по умолчанию, пустой, с параметрами, копирования.

* `this` - объектная переменная, которая находится внутри объекта и содержит ссылку на этот самый объект.

```
_____________
|height = 10|<------ (rectangle1)
|width = 15 |
|this----------
|___________| |
     ^        |
     |        |
     _________|
```

## 11.03 Инкапсуляция

* Инкапсуляция (в капсуле) - объект - это "капсула", внутри которой описывается как поведение, так и состояние. В отличие от структур в C/C++, где описывается ТОЛЬКО состояние. 

* Первое определение инкапсуляции - возможность объединения алгоритмов и структур данных в одной сущности - класса, и на основе класса создавать объект, обладающий состоянием и поведением.

* Второе определение инкапсуляции - возможность закрытия внутренней структуры данных, с целью поддержания более "корректного" кода. То есть мы ограничиваем возможности по использованию наших классов.

* Если не "защищать" внутреннюю структуру объекта, то возможны ситуации нарушения семантической целостности объекта. Следовательно, необходимо реализовать "защиту" внутренней структуры и разрешать производить только корректные измнения состояния объекта.

* В Java это достигается засчет использования модификаторов доступа, обеспечивающих различный уровень доступа.

* `private` - модификатор доступа, который закрывает возможность работы с членом класса вне этого класса. Данный модификатор обеспечивает уровень доступа "закрытый".

* Но, что делать, если мы все-таки хотим работать с полем, но обеспечить целостность данных внутри поля? Используем - методы доступа.

* Методы доступа - не являются синтаксической и обязательной единицей в Java. Они просто признак качественного ООП кода. Методы доступа позволяют обеспечить контролируемый доступ над полем.

* Выделяют методы доступа - геттеры и сеттеры.

* Геттеры имеют вид:

```
public ТИП_ПОЛЯ getНазваниеПоля() {
	return названиеПоля;
}
```

* Геттеры позволяют прочитать значение.

* Сеттеры имеют вид:

```
public void setИмяПоля(ТИП_ПОЛЯ имяПоля) {
	// тело сеттера
}
```

* `public` - модификатор доступа, позволяющий работать с классом в любом участке кода, к которому подключен данный класс. Обеспечивает уровень доступа "Открытый"

* Принято, помечать все поля `private`, все методы доступа `public`, все методы, предназначенные для внешнего использования - `public`, все методы, предназначенные для внутреннего использования - `private`.

* Если модификатор не указан, то член класса или конструктор доступны внутри данного пакета. Уровень доступа - пакетны (package internal).

## 11.04 Статические члены класса

* Члены класса (поля, методы, константы) помеченные модификатором static.

* Инициализаторы (конструкторы), но объявленные иначе.

* Статические поля - поля, глобальные для всех объектов данного класса. То есть если в одном объекте меняется значение этого поля, то оно меняется разом у всех объектов. (Правильнее - такое поле только одно, и оно доступно всем объектам).

* Со статическими полями можно (нужно) работать только через класс.

* В статическом инициализаторе можно работать ТОЛЬКО со СТАТИЧЕСКИМИ ПЕРЕМЕННЫМИ.

* Когда нужны статические переменные? - когда необходимо иметь какой-либо глобальный контекст для объектов, например - направление ветра, в программировании - "подключение к базе данных".

* Статические константы - если объявляете константу, то всегда делайте ее статической.

* Статические методы - методы, относящиеся к классу, их можно вызывать непосредственно из класса. 

* Удобно использовать тогда, когда поведение такого метода не завязано на конкретном объекте, а является поведением предметной области.

* Статически метод может работать со статическими полями и методами, но не может работать с нестатическими полями и методами.

## 11.05 Отношения между классами

* Агрегирование - связь между двумя объектами, построенная таким образом, что один объект содержит поле-ссылку на другой объект.