# 21. Хеширование

* Хеширование - процесс преобразования исходного числа в другое число по какому-либо правилу.

* Идеальное хеширование - такое преобразование чисел множества `A` в множество `B` : `A -> B`, когда элементу из `A` соответствует только один элемент множества `B`.

* Но чаще всего хеширование не является идеальным. Например MD5. (Хеш-сумма). Применяется в контрольных суммах различных файлов при их передаче по сети.

* Кто-то хочет разместить некий `FILE` в сети. Он вычисляет контрольную сумму этого файла `HASH_SUM(FILE)` - какой-то конечный хеш. Далее, выкладывает в интернет сам файл вместе с этим хешем. Любой, кто скачал данный файл, может у себя посчитать хеш от скачанного файла, и если этот хеш совпал с тем, который опубликовать человек, выложивший файл, значит файл корректен, не подменяли.
 
* Почему хеширование не бывает идеальным? Потому что исходное множество `A` всегда неограничено (например, множество всех строк), а множество `B` всегда ограничено. Возникают так называемые коллизии, например, при хешировании `a1, a100, a500` -> `b7`.

## 21.00 Хеширование в проектировании `Maps`

* Задача - обеспечить быстрый доступ по ключу к элементам карты.

* Решение - что позволяет очень быстро обращаться к значению по ключу? В обычном массиве получение элемента по индексу занимает очень малое время.

* Следовательно, наша задача ставится следующим образом:

```
A* -> B*

B* -> A* (в чистом виде нельзя).

где A* - это любой тип ключа, а B* - это число диапазоне int. 
```

* Для этого в Java в классе Object создана функция хеширования. 

```
public int hashCode();
```

* Общий алгоритм -> `put("Марсель", 25);`, вычисляем хеш-код от `"Марсель"`, этот хеш-код будет индексом в массиве, куда мы положим `25`.

## 21.01 Хеширование строк

Алгоритм:

1. Получаем код каждого символа строки.
2. Сложить, учитывая порядок.

```JAVA
int h = hash; // изначально равно 0
if (h == 0 && value.length > 0) { // если хеш до этого не считали, и длина строки больше 0
            char val[] = value; // имеем массив всех символов строки

            for (int i = 0; i < value.length; i++) { // бежим по всем символам
                h = 31 * h + val[i]; // прибавляем к хешу текуший символ, предварительно умножив на 31
            }

            hash = h;
        }
        return h;
```	


Как работает алгоритм?

"abcd" -> 97, 98, 99, 100

```
h = (((31 * 0 + 97) * 31 + 98) * 31 + 99) * 31 + 100 = 97 * 31 ^ 3 + 98 * 31 ^ 2 + 99 * 31 ^ 1 + 100 * 31 ^ 0 ->

SUM(0 .. n-1) c[i] * 31^(n-1-i)
```

## 21.02 Хеширование отстальных типов

* int -> hashCode = int

* boolean -> hashCode = 1,0

* char -> hashCode = код (int)char

и далее - чуть сложнее. 

## 21.03 Нюансы использования хеш-функций при реализации `Map`

* Хеш-код - огромное число, создавать массив из около четырех миллиардов элементов не очень.

* Необходимо научиться обрезать хеш-код.

* Для обрезания хеш-кода используется функция логического умножения.

```
188 & 27 = 24

10111100
   11011
--------
00011000 -> 24(10)
```

* Следовательно формула определния индекса ключа в массиве -> ключ.hashCode() & (размер-массива - 1).

* Какой размер массива надо подбирать?

* Идеальный стартовый размер - 16.

```
138 & 16 -> 

10001010
    1111
--------
    1010

для других чисел - 

10001100
    1111
--------
    1100
```