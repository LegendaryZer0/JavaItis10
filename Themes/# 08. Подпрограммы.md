# 8. Подпрограммы

* Подпрограмма - набор инструкций для многократного вызова по названию.

* Подпрограммы упрощают написание кода, исправление ошибок; позволяют избежать дублирования кода.

## 8.00 Функции

* Функции - набор инструкций, который выполняет определенные действия, а также может возвратить какое-либо значение.

* Аргумент - конкретное значение, которое передается в формальный параметр при вызове функции.

* Сигнатура функции(метода) - тип возвращаемого занчения + название + формальные параметры (без тела).

* Без использования функции:

```JAVA
public static void main(String[] args) {
	int a[] = {3, 2, -1, 30, 20};
	int b[] = {1, 4, 5, -1};

	int maxValueOfA = a[0];
	for (int i = 1; i < a.length; i++) {
		if (maxValueOfA < a[i]) {
			maxValueOfA = a[i];
		}
	}
	System.out.println(maxValueOfA);

	int maxValueOfB = b[0];
	for (int i = 1; i < b.length; i++) {
		if (maxValueOfB < b[i]) {
			maxValueOfB = b[i];
		}
	}
	System.out.println(maxValueOfB);
}
```

* С использованием функций:

```JAVA
// функция

// public static - magic
// int - тип возвращаемого значения -> значение какого типа мы хотим вернуть?
// max - название функции
// int array[] - формальный параметр
public static int max(int array[]) {
	int result = array[0];
	for (int i = 1; i < array.length; i++) {
		if (result < a[i]) {
			result = a[i];
		}
	}
	// return - оператор возврата значения из функции
	return result;
}

public static void main(String[] args) {
	int a[] = {3, 2, -1, 30, 20};
	int b[] = {1, 4, 5, -1};

	// a -> аргумент
	// b -> аргумент
	// вместо max(a) и max(b) после выполнения функций
	// будет находится их результат
	int maxValueOfA = max(a);
	int maxValueOfB = max(b);
	System.out.println(maxValueOfA);
	System.out.println(maxValueOfB);
}
```

### Зачем для функций писать тип возвращаемого значения?

* Чтобы не было проблем с присваиванием какой-либо переменной значения функции, которое не подходит данной переменной.

```JAVA
public static double sqrt(double x) {
	double result = 0.0;
	...
	return result;
} 
public static void main(String[] args) {
	int a = sqrt(7.5);
}
```

### Почему java сама не может вычислить тип и не обязывать программиста указывать это?

* Пусть `main` объявлен в классе `Program.java`, а `sqrt` в классе `Math.java`. Когда компилятор будет компилировать файл `Program.java`, он не может анализировать весь код `Math.java` чтобы понять, что вызов метода `sqrt` адекватен.

* Компилятор при компиляции `main` в `Program.java` смотрим сигнатуру метода `sqrt` и смотрит тип возвращаемого значения, и проверяет, все ли адекватно, не залезая внутрь `sqrt`.

## 8.01 Процедуры

* Разновидность подпрограмм, которые явно не возвращают значение своего выполнения, но обладают побочным эффектом.

```JAVA
public static void printNumbersInRange(int a, int b) {
	for (int i = a; i <= b; i++) {
		System.out.print(i + " ");
	}
}

public static void main(String args[]) {
	printNumbersInRange(4, 10);
}
```

## 8.02 Передача аргументов в формальные параметры функций и процедур

### Передача по значению

* В данном примере существуют 4 переменные. Две - формальные параметры процедуры `swap`, две - аргументы внутри `main`.

* При записи `swap(x,y)` в формальные параметры передаются копии исходных переменных. Изначальные `x` и `y` никак не меняются.

* Такой принцип передачи аргументов в формальные параметры называется - `по значению`.

```C
void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
}
int main()
{
    int x = 6;
    int y = 10;
    swap(x, y);
    cout << x << " " << y;
}
```

### Передача по ссылке 

* При такой передаче аргументов внутрь подпрограммы попадают исходные переменные (потому что передается адреса самих исходных переменных.)

```C
void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}
int main()
{
    int x = 6;
    int y = 10;
    swap(x, y);
    cout << x << " " << y;
}
```

### А как в Java?

* В java аргументы в формальные параметры передаются ВСЕГДА ПО ЗНАЧЕНИЮ.

* НО, когда в качестве аргумента выступает переменная ссылочного типа, то в качестве значения передается ссылка на объект, таким образом, все манипуляции внутри процедуры происходят над реальным объектом. (например, над массивом.).