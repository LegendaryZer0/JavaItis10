# 34. ORM/JPA/HIBERNATE.md

## 34.00 ORM

* ORM - Object Relation Mapping - объектно-ориентированное отображение. Концепция, суть которой заключается в автоматическом преобразовании OOП-сущностей в реляционные отношения. Грубо говоря: класс = таблица, поле = колонка, объект = строка. ORM подразумавает написание таких запросов к БД, которые сторятся не на основе таблиц, а на основе классов.

* JPA - Java Persistance (постоянство, постоянный) API - конкретная спецификация ORM в Java, то есть требования к ORM-фреймворкам. Описывается пакетом `javax.persistence`. В нем содержатся интерфейсы и аннотации (`@Column`, `@Entity`, `@OneToMany` и т.д.) для реализации `ORM`. То есть каждый фрейморк, который реализует ORM в Java по-хорошему должен отвечать этому стандрату.

* Hibernate - ORM-фреймворк (задает каркас разработки), конкретная реализация ORM в Java. Умеет генерировать SQL-запросы автоматически. Hibernate это реализация JPA в Java.

## 34.01 Hibernate

* `hbm.xml` - специальный конфигурационный файл Hibernate, в котором мы описываем соответствие между классами и таблицами, полями и колонками.

* `hibernate.cfg.xml` - главный конфигурационный файл Hibernate. Здесь мы описываем основные настройки для подключения к БД, настройки самого Hibernate, а также ссылки на `hbm.xml`.

* HQL - специальный язык запросов Hibernate, который работает не с таблица, а с классами.

## ВОПРОСЫ

1. Почему мы используем в `xml-конфиге` параметр `table` и в аннотациях аннотацию `@Table` при описании маппинга класса `User`?

* ОТВЕТ: Аннотация `@Table` и параметр `table` указывают, как будет называться таблица, привязанна к классу. Если мы не указываем аннотацию или параметр, то таблица будет называться так же, как и класс. В Postgres таблица `user` уже зарезервирована.

2. Почему аннотации и `xml` работают по-разному и мне пришлось переписывать код?

* ОТВЕТ: в случае `xml` у нас объектом-родителем является `User` и поэтому сохранение машин должно идти через `User`. Сначала создаем машину, сохраняем ее в бд, потом кладем ее в юзера и сохраняем юзера. В случае аннотации, аннотации `@OneToMany` и `@JoinColumn` делают класс `Car` основным. Поэтому здесь мы сначала создаем машину, потом кладем в нее пользователя, сохраняем машину - и все ок.

3. Почему в таблицах было `owner_id = null`, но когда мы доставали пользователей, машины у них были занесены.

* ОТВЕТ: потому что доставали пользователей из кэша.