# Словарь понятий и определений

## 01. ООП, ООП в Java

* `Объектно-ориентированная парадигма программирования` - данная парадигма определяет вид вычислений в программе как совокупность объектов, которые обмениваются между собой сообщениями. 

* `Объект` - конкретная сущность, обладающая свойствами и поведением. Каждый объект создается на основе класса (объект - это экземпляр класса).

* `Класс` - абстрактный тип данных. Тип данных, определенный программистом. В отличие от фундаментальных типов - логического, числового, символьного и т.д. Класс - это шаблон, на основе которого создаются объекты. Все программирование на Java сводится к написанию классов.

* `Член класса` - определенные элементы класса, которые попадают в объект, и при этом могут наследоваться.

* `Структура класса` - поля, методы, конструктор (конструктор не является методом, членом класса).

* `Поле` - член класса. Конкретное значение поля определяет состояние объекта. Представляет собой переменную, определенную в области видимости класса.

* `Метод` - член класса, определяющий конкретное поведение объекта класса. У всех объектов одного класса одинаковое поведение. Представляет собой функцию (возвращает значение) или процедуру (не возвращает значение в явном виде, но может иметь побочный эффект - функция тоже может иметь побочный эффект), описанную в области видимости класса.

```JAVA
public int sum(int a, int b) {
	// возвращает значение в явном виде
	return a + b;
}

// процедура в явном виде результат не возвращает.
// но результат выполнения есть - измененный массив array
public void allToValue(int value, int array[]) {
	for (int i = 0; i < array.lenght; i++) {
		array[i] = value;
	}
}

// функция с побочным эффектом
public int add(int value, int array[]) {
	// добавляем value в конец массива
	// если места не хватило, возвращаем -1, если хватило возвращаем 0 
	if (count < array.lenght) {
		array[count++] = value;
		return 0;
	} else return -1;
}
```

* `Конструктор` - набор инструкций (согласно спецификации - специальный метод), выполняющий инициализацию созданного объекта, т.е. задает начальное состояние объекта. Вызывается вместе с оператором `new` - оператор создания объекта (выделения памяти). Бывают конструкторы пустые, с параметрами, копирования. Конструктор может быть перегружен, но не может быть переопределен, поскольку не наследуется.

* `Конструктор по-умолчанию` - конструктор, который по умолчанию присутствует во всех классах, если не объявлен другой. Данный конструктор является пустым.

* `Область видимости` - определенная область кода, ограниченная фигурными скобками, внутри которой видны объявленные в ней переменные, и переменные, объявленные в обрамляющей области видимости до текущей.

```JAVA
{
	int a;
	{
		int b;
		// видны и a и b
	}
	int c;
	// b - не видна
}
```

* `Уровень доступа` - каждый член класса может быть доступен в любом месте программы. Уровни доступа ограничивают возможность использования члена класса вне этого класса. Открытый, защищенный, закрытый, пакетный.

* `Модификатор доступа` - определяет уровень доступа, открытый - `public`, защиненный - `protected`, закрытый - `private`, пакетный - отсутсвие модификатора.

* `Инкапсуляция` - принцип ООП. Определяет объект как капсулу, состояние которого защищенно от измненений вне этого объекта. Объект содержит внутри себя поведение и состояние. Защищенность объекта достигается засчет - модификаторов доступа и методов доступа.

* `Методы доступа` - предоставляют контролируемый доступ над состоянием объекта.

* `Наследование` - принцип ООП. Базовые понятия - класс-предок, класс-потомок. Наследование позволяет объектам класса-потомка копировать состояние объектов класса-предка, копировать поведение, а также переопределять поведение (написать новую реализацию).

* `Восходящее преобразование` - неявное преобразование. Возможность в объекной переменной класса-предка содержать ссылку на объект класса потомка.

* `Нисходящее преобразование` - явное преобразование. Сохранение в об]ектной переменной класса-потомка ссылки на объект, которая содержалась в объектной переменной класса-предка. В случае, когда в объектной переменной класса-предка содержалась ссылка на другой класс (не тот, к которому преобразуем) - произойдет ошибка преобразования.

```JAVA
class Human extends Monkey {

}  
class Woman extends Monkey {

}

Human marsel = new Human();
Woman aliya = new Woman();

Monkey marselMonkey;
marselMonkey = marsel;

Monkey aliyaMonkey;
aliyaMonkey = aliya;

Human man = (Human)marselMonkey;
// ошибка преобразование
Human notMan = (Human)aliyaMonkey;
```

* `Полиморфизм` - возможность работы с объектами разных типов таким образом, будто они принадлежат одному типу. Достигается засчет восходящего преобразования и наследования.

* Модификатор доступа `protected` - член класса доступен в потомках и внутри пакета.

* `Перегрузка метода` - наличие в классе методов, имеющих разную сигнатуру (формальные параметры), но одинаковые наименования.

* `Переопределение метода`  - наличие в потомке метода, имеющего ту же сигнатуру, что и метод в предке, но с другой реализацией.

### ВАЖНО!

Методы, имеющие одинаковую сигнатуру, но разный тип возвращаемого значения недопустимы.

В случае, когда при переопределении метода мы меняем его сигнатуру, то такой метод не является переопределенным, он является - перегруженным.

```JAVA
class B {
	public void some() {
		...
	}
}
class A extends B {
	// переопределение
	public void some() {
		...
	}

	// перегрузка
	public void some(String text) {

	}
}
```

* Ключевое слово `this` - объектная переменная, которая содержит ссылку на объект "самого себя".

* Ключевое слово `super` - ссылка на объект класса-предка внутри объекта класса-потомка. В случае, если указываются круглые скобки - конструктор класса-предка.

* Правило `определения конструктора в потомке` - внутри конструктора класса-потомка первым делом следует вызвать конструктор класса-предка через `super`, иначе программа не скомпилируется.

* `Абстрактные классы` - классы, на основе которых нельзя создать объект, но можно создать объектную переменную данного типа.

```JAVA
abstract class A {

};

class B extends A {

}

// нельзя
A a = new A();
// можно
A a = new B();
```

* `Абстрактный метод` - метод, не имеющий реализацию. Если в классе есть хотя бы один абстрактный метод, то класс должен быть помечен как абстрактный.

* Правила `наследования абстрактных классов` - если класс наследует абстратктный класс, в котором есть хотя бы один абстрактный метод, то этот класс-потомок обязан реализовать этот метод, либо быть помечен как абстрактный.

* `Интерфейс` - конструкция, которая может содержать только методы без реализации. Объекты интерфейсного типа создавать нельзя, но можно создавать объектные переменные. Классы могут имплементировать (реализовывать) интерфейсы (с обязательно реализацией всех методов интерфейса, иначе механизм как с абстрактными). Класс может имплементировать более одного интерфейса (но не может наследоваться более чем от одного класса).

* `Финальный класс` - класс, от которого нельзя наследоваться.

* `Финальная переменная/поле` - константа, значение может быть присвоено только один раз.

* `Статические поля` - поля, принадлежащие классам, а не объектом. Статическое поле является единственным и глобальным для всех объектов. 

```JAVA
class A {
	public static int staticField;
	public int field;
}

A a = new A();
a.staticField = 100;

A b = new A();
b.staticField = 200;

System.out.println(a.staticField); // 200
```

* `Статические методы` - методы, которые принадлежат классу, а не объекту.

```JAVA
class A {
	public static void someMethod() {
		...
	}
}
```

## ВАЖНО!!!

Статические поля и методы доступны без создания объектов, с помощью оператора `.` после указания имени класса.

```JAVA
A.someMethod();
A.someField = 10;
```

Статические методы имеют доступ ТОЛЬКО к статическим методам и статическим полям.

* `Статические инициализаторы` - инициализатор, аналогичный конструктору, но вызываемый при первом обращении к классу (его загрузке в JVM).

```JAVA
class A {
	public static int someStaticField;
	public static int anoterStaticField;

	static {
		someStaticField = 10;
		anoterStaticField = 15;
	}
}
```

* `Поток данных в терминах IO` - последовательность байт.

* `Три базовых потока, которые открываются при запуске приложения` - System.in, System.out, System.err

```JAVA
class System {
	public final static InputStream in = null;
	public final static PrintStream out = null;
	public final static PrintStream err = null;
}
```

* `InputStream` - абстрактный класс. В данном классе частично заложена реализация логики работы с потоками. В частности:

```JAVA
public int read(byte b[], int off, int len) throws IOException {
        if (b == null) {
            throw new NullPointerException();
        } else if (off < 0 || len < 0 || len > b.length - off) {
            throw new IndexOutOfBoundsException();
        } else if (len == 0) {
            return 0;
        }

        int c = read();
        if (c == -1) {
            return -1;
        }
        b[off] = (byte)c;

        int i = 1;
        try {
            for (; i < len ; i++) {
                c = read();
                if (c == -1) {
                    break;
                }
                b[off + i] = (byte)c;
            }
        } catch (IOException ee) {
        }
        return i;
    }
```

Данный метод базируется на абстрактном методе 

```JAVA
public abstract int read() throws IOException;
```

Почему возвращаем int? (См. лекцию).

* `FileInputStream` - класс, потомок `InputStream` и его реализация `read` позволяет читать байты из файла. Реализован через вызов нативного метода `read0`.

* `BufferedInputStream` - используется в System.in. Имеет поле 

```JAVA
protected volatile byte buf[];
```

представляющее собой буффер байтов.

* `PrintStream` - класс, выводит информацию в правильной кодировке системы, а также позволяет выводить информацию с новой строки. Поддерживает буфферизацию.

* `FilterInputStream`, `FilterOutputStream` - декораторы, они позволяют частично переделать поведение классических OutputStream и InputStream

* `Reader` и `Writer` - абстрактные классы, описывающие логику работы с потоками символов.

```JAVA
abstract public int read(char cbuf[], int off, int len) throws IOException;
```

Данные классы необходимы при работе с текстовой информацией, поскольку один символ занимает как правило 2 байта в кодировке Unicode.

* `FileReader`, `FileWriter`, `InputStreamReader` (принимает на вход поток байтов, выдает поток символов) - различные реализации ` Read/Writer`.

* `BufferedReader` - такая реализация `Reader`, которая буферизирует данные в оперативной памяти, в частности в массиве `private char cb[];`, таким образом работа с потоком ускоряется. Использование данного класса предпочтительно. Аналогично `BufferedWriter`.

* `Object` - суперкласс - предок всех остальных классов, следовательно, любая объектная переменная может быть преобразована по правилу восходящего преобразования в этот тип. Имеет важные методы, среды которых:

```JAVA
int hashCode();
boolean equals(Object obj);
String toStirng();

void wait();
void notify();
void notifyAll();
```

* `Обобщенные типы или дженерики` - механизм, позволяющий говорить о типах в терминах неизвестных типов. То есть, мы не знаем, какого типа будут эти объекты, но мы точно знаем что они будут одного типа. При компиляции проверка, действительно ли код составлен таким образом, что гарантируется "одинаковость типов", далее типы "стираются" и заменяются на Object.

Поскольку вы хотите, чтобы списки и т.д. могли поддерживать фундаментальные типы - целочисленные, вещественные, символьные и т.д. (в jave представлены примитивными типами) для них существуют оберточные типы. Они позволяют запихнуть примитив в дженерик.

* `StringPool` - область памяти, где содержаться все строки, явно объявленные в приложении. Каждая объектная переменная содержит ссылку на StringPool, если строка для этой переменной была объявлена в коде (литеральная строка). Сделано это для экономии памяти.

* `IntegerCache` - массив объектов типа Integer (по умолчанию в диапазоне от -128 до 127). Все объекты типа Integer в данном диапазоне ссылаются на объекты из `IntegerCache`. 

* `Коллекция` - контейнер объектов. Примеры коллекций - коллекция (элементы не упорядочены), список (элементы упорядочены), словарь (наличие ключ-значения), множество (коллекция, уникальные).

* `Iterable<T>` -  интерфейс, который указывает на то, что коллекция может быть итерируема.

* `Iterator<T>` - интерфейс, описывает поведение объекта, который может "гулять" как "курсор" по коллекции, указывает между двумя объектами.

* `Collection<T>` - интферфейс, потомок `Iterable`, описывает поведение коллекции, с методом добавления элемента, проверки - содержится ли какой-либо элемент в коллекции и т.д.

* `List<T>` - интерфейс, потомок `Collection`, делает все то же самое, что и `Collection`, но имеет метод `get(int index)`.

* `ArrayList<T>` - класс, реализующий `List` на основе массива. При переполеннии массива создается массив на половину длиннее предыдущего, в который копируются все старые данные. Ограничение по размеру - MAX_INT - 8.

* `LinkedList<T>` - класс, реализующий `List` на основе узлов (двусвязного списка). Не имеет ограничений по размеру, позволяет очень быстро проводить операции вставки в начало и в конец. Ограничение по размеру - оперативная память, выделенная Java-машине.

* `Map<K, V>` - интерфейс, ассоциативный массив. Позволяет хранить какое-либо значение по ключу. Ключ должен быть уникальным.

* `HashMap<K,V` - класс, реализация `Map` на основе массива корзин. Каждая корзина - связный список (набор узлов). Добавление/получение элементов базируется на функциях `hashCode` и `equals`.

* `Set<V>` - интерфейс, описывающий множество. 

* `HashSet<V>` - класс, реализация `Set` на основе `HashMap`. 

* Разница между `ошибками компиляции` и `ошибками времени выполнения` - первое - это нарушение синтаксиса языка. Второе - неправильная логика и ошибка происходит в момент работы программы, такие ошибки будем называть `исключениями`.

* Все исключения в Java - это объекты, классы которых являются потомками `Throwable`.

* `Exception` - объекты данного класса и его потомков (кроме `RuntimeException`) являются проверяемыми исключениями, такие исключения нужно явно обрабатывать в коде с помощью `try-catch-finally`, либо "пробрасывать наверх" пока следующий программист ее не перехватит.

* `RuntimeException` - потомок `Exception`, объекты этого класса и его потомков предсталвяют собой "непроверяемые исключения".    

* `Error` - системные ошибки, непроверяемые.

