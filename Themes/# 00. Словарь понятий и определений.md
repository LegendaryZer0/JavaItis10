# Словарь понятий и определений

## 01. ООП, ООП в Java

* `Объектно-ориентированная парадигма программирования` - данная парадигма определяет вид вычислений в программе как совокупность объектов, которые обмениваются между собой сообщениями. 

* `Объект` - конкретная сущность, обладающая свойствами и поведением. Каждый объект создается на основе класса (объект - это экземпляр класса).

* `Класс` - абстрактный тип данных. Тип данных, определенный программистом. В отличие от фундаментальных типов - логического, числового, символьного и т.д. Класс - это шаблон, на основе которого создаются объекты. Все программирование на Java сводится к написанию классов.

* `Член класса` - определенные элементы класса, которые попадают в объект, и при этом могут наследоваться.

* `Структура класса` - поля, методы, конструктор (конструктор не является методом, членом класса).

* `Поле` - член класса. Конкретное значение поля определяет состояние объекта. Представляет собой переменную, определенную в области видимости класса.

* `Метод` - член класса, определяющий конкретное поведение объекта класса. У всех объектов одного класса одинаковое поведение. Представляет собой функцию (возвращает значение) или процедуру (не возвращает значение в явном виде, но может иметь побочный эффект - функция тоже может иметь побочный эффект), описанную в области видимости класса.

```JAVA
public int sum(int a, int b) {
	// возвращает значение в явном виде
	return a + b;
}

// процедура в явном виде результат не возвращает.
// но результат выполнения есть - измененный массив array
public void allToValue(int value, int array[]) {
	for (int i = 0; i < array.lenght; i++) {
		array[i] = value;
	}
}

// функция с побочным эффектом
public int add(int value, int array[]) {
	// добавляем value в конец массива
	// если места не хватило, возвращаем -1, если хватило возвращаем 0 
	if (count < array.lenght) {
		array[count++] = value;
		return 0;
	} else return -1;
}
```

* `Конструктор` - набор инструкций (согласно спецификации - специальный метод), выполняющий инициализацию созданного объекта, т.е. задает начальное состояние объекта. Вызывается вместе с оператором `new` - оператор создания объекта (выделения памяти). Бывают конструкторы пустые, с параметрами, копирования. Конструктор может быть перегружен, но не может быть переопределен, поскольку не наследуется.

* `Конструктор по-умолчанию` - конструктор, который по умолчанию присутствует во всех классах, если не объявлен другой. Данный конструктор является пустым.

* `Область видимости` - определенная область кода, ограниченная фигурными скобками, внутри которой видны объявленные в ней переменные, и переменные, объявленные в обрамляющей области видимости до текущей.

```JAVA
{
	int a;
	{
		int b;
		// видны и a и b
	}
	int c;
	// b - не видна
}
```

* `Уровень доступа` - каждый член класса может быть доступен в любом месте программы. Уровни доступа ограничивают возможность использования члена класса вне этого класса. Открытый, защищенный, закрытый, пакетный.

* `Модификатор доступа` - определяет уровень доступа, открытый - `public`, защиненный - `protected`, закрытый - `private`, пакетный - отсутсвие модификатора.

* `Инкапсуляция` - принцип ООП. Определяет объект как капсулу, состояние которого защищенно от измненений вне этого объекта. Объект содержит внутри себя поведение и состояние. Защищенность объекта достигается засчет - модификаторов доступа и методов доступа.

* `Методы доступа` - предоставляют контролируемый доступ над состоянием объекта.

* `Наследование` - принцип ООП. Базовые понятия - класс-предок, класс-потомок. Наследование позволяет объектам класса-потомка копировать состояние объектов класса-предка, копировать поведение, а также переопределять поведение (написать новую реализацию).

* `Восходящее преобразование` - неявное преобразование. Возможность в объекной переменной класса-предка содержать ссылку на объект класса потомка.

* `Нисходящее преобразование` - явное преобразование. Сохранение в об]ектной переменной класса-потомка ссылки на объект, которая содержалась в объектной переменной класса-предка. В случае, когда в объектной переменной класса-предка содержалась ссылка на другой класс (не тот, к которому преобразуем) - произойдет ошибка преобразования.

```JAVA
class Human extends Monkey {

}  
class Woman extends Monkey {

}

Human marsel = new Human();
Woman aliya = new Woman();

Monkey marselMonkey;
marselMonkey = marsel;

Monkey aliyaMonkey;
aliyaMonkey = aliya;

Human man = (Human)marselMonkey;
// ошибка преобразование
Human notMan = (Human)aliyaMonkey;
```

* `Полиморфизм` - возможность работы с объектами разных типов таким образом, будто они принадлежат одному типу. Достигается засчет восходящего преобразования и наследования.

* Модификатор доступа `protected` - член класса доступен в потомках и внутри пакета.

* `Перегрузка метода` - наличие в классе методов, имеющих разную сигнатуру (формальные параметры), но одинаковые наименования.

* `Переопределение метода`  - наличие в потомке метода, имеющего ту же сигнатуру, что и метод в предке, но с другой реализацией.

### ВАЖНО!

Методы, имеющие одинаковую сигнатуру, но разный тип возвращаемого значения недопустимы.

В случае, когда при переопределении метода мы меняем его сигнатуру, то такой метод не является переопределенным, он является - перегруженным.

```JAVA
class B {
	public void some() {
		...
	}
}
class A extends B {
	// переопределение
	public void some() {
		...
	}

	// перегрузка
	public void some(String text) {

	}
}
```

* Ключевое слово `this` - объектная переменная, которая содержит ссылку на объект "самого себя".

* Ключевое слово `super` - ссылка на объект класса-предка внутри объекта класса-потомка. В случае, если указываются круглые скобки - конструктор класса-предка.

* Правило `определения конструктора в потомке` - внутри конструктора класса-потомка первым делом следует вызвать конструктор класса-предка через `super`, иначе программа не скомпилируется.

* `Абстрактные классы` - классы, на основе которых нельзя создать объект, но можно создать объектную переменную данного типа.

```JAVA
abstract class A {

};

class B extends A {

}

// нельзя
A a = new A();
// можно
A a = new B();
```

* `Абстрактный метод` - метод, не имеющий реализацию. Если в классе есть хотя бы один абстрактный метод, то класс должен быть помечен как абстрактный.

* Правила `наследования абстрактных классов` - если класс наследует абстратктный класс, в котором есть хотя бы один абстрактный метод, то этот класс-потомок обязан реализовать этот метод, либо быть помечен как абстрактный.

* `Интерфейс` - конструкция, которая может содержать только методы без реализации. Объекты интерфейсного типа создавать нельзя, но можно создавать объектные переменные. Классы могут имплементировать (реализовывать) интерфейсы (с обязательно реализацией всех методов интерфейса, иначе механизм как с абстрактными). Класс может имплементировать более одного интерфейса (но не может наследоваться более чем от одного класса).

* `Финальный класс` - класс, от которого нельзя наследоваться.

* `Финальная переменная/поле` - константа, значение может быть присвоено только один раз.

* `Статические поля` - поля, принадлежащие классам, а не объектом. Статическое поле является единственным и глобальным для всех объектов. 

```JAVA
class A {
	public static int staticField;
	public int field;
}

A a = new A();
a.staticField = 100;

A b = new A();
b.staticField = 200;

System.out.println(a.staticField); // 200
```

* `Статические методы` - методы, которые принадлежат классу, а не объекту.

```JAVA
class A {
	public static void someMethod() {
		...
	}
}
```

## ВАЖНО!!!

Статические поля и методы доступны без создания объектов, с помощью оператора `.` после указания имени класса.

```JAVA
A.someMethod();
A.someField = 10;
```

Статические методы имеют доступ ТОЛЬКО к статическим методам и статическим полям.

* `Статические инициализаторы` - инициализатор, аналогичный конструктору, но вызываемый при первом обращении к классу (его загрузке в JVM).

```JAVA
class A {
	public static int someStaticField;
	public static int anoterStaticField;

	static {
		someStaticField = 10;
		anoterStaticField = 15;
	}
}
```

* `Поток данных в терминах IO` - последовательность байт.

* `Три базовых потока, которые открываются при запуске приложения` - System.in, System.out, System.err

```JAVA
class System {
	public final static InputStream in = null;
	public final static PrintStream out = null;
	public final static PrintStream err = null;
}
```

* `InputStream` - абстрактный класс. В данном классе частично заложена реализация логики работы с потоками. В частности:

```JAVA
public int read(byte b[], int off, int len) throws IOException {
        if (b == null) {
            throw new NullPointerException();
        } else if (off < 0 || len < 0 || len > b.length - off) {
            throw new IndexOutOfBoundsException();
        } else if (len == 0) {
            return 0;
        }

        int c = read();
        if (c == -1) {
            return -1;
        }
        b[off] = (byte)c;

        int i = 1;
        try {
            for (; i < len ; i++) {
                c = read();
                if (c == -1) {
                    break;
                }
                b[off + i] = (byte)c;
            }
        } catch (IOException ee) {
        }
        return i;
    }
```

Данный метод базируется на абстрактном методе 

```JAVA
public abstract int read() throws IOException;
```

Почему возвращаем int? (См. лекцию).

* `FileInputStream` - класс, потомок `InputStream` и его реализация `read` позволяет читать байты из файла. Реализован через вызов нативного метода `read0`.

* `BufferedInputStream` - используется в System.in. Имеет поле 

```JAVA
protected volatile byte buf[];
```

представляющее собой буффер байтов.

* `PrintStream` - класс, выводит информацию в правильной кодировке системы, а также позволяет выводить информацию с новой строки. Поддерживает буфферизацию.

* `FilterInputStream`, `FilterOutputStream` - декораторы, они позволяют частично переделать поведение классических OutputStream и InputStream

