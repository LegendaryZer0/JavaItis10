# 32. Spring

* Spring - фреймворк. Фреймворк - это набор библиотек. Фреймворк навязывает свою архитектуру/структуру/каркас приложения. Фреймворк облегчает разработку ПО.

* Spring состоит из огромного количество библиотек. Можно выделить следуюющие:

`spring-jdbc` - библиотека для работы с БД через JDBC.

`spring-security` - библиотека(фреймворк) для обеспечения безопасности Web-приложений.

`spring-aop` - библиотека(фреймворк) для обеспечения сквозной логики.

`spring-webmvc` - библиотека(фреймворк) для реализации Web-приложений.

`spring-boot` - фреймворк, основанный на Spring. Позволяет реализовывать сложные Enterprise-решения по щелчку :) Благодаря обширым возможностям автоконфигурации.

`spring-cloud` - фреймворк для реализации микросервисной архитектуру.

## 32.00 Основная концепция Spring

* DI/IoC - центральные паттерны, которые реализованы в Spring. 

* Beans (бины) - компоненты (чаще всего, обычные объекты). Программист описывает классы, на основе которых создаются эти объекты. Само связывание этих объектов проиходит внутри "контейнера бинов".

* `ApplicationContext` - интерфейс, центральный интерфейс Spring. Объекты классов, которые реализуют данный интерфейс представляют собой контейнеры бинов.

* `@Autowired` - аннотация, которая автоматически проставляет бин. Можно вешать на поле, сеттер и конструктор.

* Следовательно, используем совмещенную конфигурацию, основанную на аннотации `@Autowired` для классов, которые написаны нами, и `xml` для не наших классов.

* `@Component` - аннотация, которая навешивается на класс и говорит `Spring` о том, что объект данного класса будет бином. 

* `@Bean` - аннотация, которой помечаются методы, создающие бины.

## С чего начинали?

1. Бины объявляются в `context.xml`, для каждого бина указывается его `id` и класс, на основе которого он создается. Связи между бинами задаются с помощью `ref`.

2. Убрали связи между бинами в классах, которые мы создали сами и заменили их на `@Autowired`.

3. Убрали объявления бинов в `context.xml` для классов, написанных нами и заменили это аннотацией `@Component` и добавив `component-scan` в `context.xml`.

4. Убрали все бины, которые были в `context.xml`, использовав аннотацию `@Bean` в специальном конфигурационном классе.

## Объявление бинов

* Есть несколько способов объявления бина. Важно, что у бина есть его id.

1) Объявление бина в файле `context.xml`:

```XML
<bean id="someClass" class="SomeClass">
	<constructor-arg .../>
	<property .../>
</bean>
```

2) Объявление бина путем навешивания на класс аннотации `@Component`. В таком случае Spring создать бин-объект на основе данного класса и присвоит ему id согласно `value` или по названию класса, если `value` не указан, например `someClass`

```JAVA
@Component(value = "id БИНА")
class SomeClass {

}
```

3) С помощью аннотации `@Bean`, которая навещивается на метод, создающий объект-бин. Id бина в этом случае совпадает с названием метода. В данном случае создается отдельный класс, помечаемый аннотацией `@Configuration`, в котором описываются специальные фабричные метода для создания бинов.

```JAVA
@Bean
public SomeClass someClass() {
	return new SomeClass();
}
```

## Связывание бинов

* Есть три способа связывания бинов.

1) В `context.xml` при объявлении бина указать `ref` на другой бин.

```XML
<bean id="someBean" class="SomeClass">
	<constructor-arg ref="anotherBean"/>
</bean>

<bean id="anotherBean" class="AnotherClass"/>
```

2) С помощью аннотации `@Autowired` - данная аннотация сама найдет подходящий бин и засунет его в другой бин. В случае, если кандидатов на автосвязывание несколько, необходимо использовать аннотацию `@Qualifier("id необходимого бина")`.

```JAVA
@Component(value = "id БИНА")
class SomeClass {

	@Autowired
	private AnotherClass anotherBean;
}
```

3) Связывание бинов при использовании аннотации `@Bean`:

```JAVA
@Configuration
public class Config {
	@Bean
	public SomeClass someBean() {
		return new SomeClass(anotherBean());
	}

	@Bean
	public AnotherClass anotherBean() {
		return new AnotherClass();
	}
}
```
## Особенности конфигурации

* Возможно использовать следующие типы конфигурации:

1) XML - в этом случае используется контейнер `ClassPathXmlApplicationContext`.

2) Совмещенная, с Java-конфигурацией (аннотации `@Bean`, `@Component`)

В этих двух случаях основной конфигурацией является `context.xml`, при этом, для использования `@Bean` необходимо создать отдельный конфигурационный класс, помеченный аннотацией `@Configuration`.

Для того, чтобы `context.xml` мог видеть все классы, помеченные аннотациями `@Bean`, `@Component`, `@Configuration` необходимо в `context.xml` добавить параметр, где вы укажете пакет, где следует искать все бины.

```XML
<context:component-scan base-package="ru.itis.spring"/>
```

Если вы хотите проставлять значения каких-либо полей, которые не ссылаются на бины, удобно использовать отдельный `properties`-файл и аннотацию `@Value("${название-свойства}")`.

В самом `context.xml` необходимо указать расположение этого файла:

```XML
<context:property-placeholder location="classpath*:ru.itis/application.properties" />
```

3) Использование чистой Java-конфигурации. Для этого класс, помеченный аннотацией `@Configuration` становится центральным классом-конфигурацией. `context.xml`  при этом удаляется. Для того, чтобы использовать контейнер на основе Java-конфига мы применяем `AnnotationConfigApplicationContext`. В классе-конфигурации обязательно указать аннотацию `@ComponentScan("ru.itis.spring")`, аналогичную соответствующей записи в `context.xml`. Аналогично, для подключения `properties`-файла используем `@PropertySource("ru.itis\\application.properties")`.

## Рекомендации

1) В практической разработке удобнее всего использовать полную Java-конфигурацию с `properties`-файлами. Если иногда требуется менять конфигурацию, вполне можно обойтись `@Qualifier`.

2) Если же, в приложении существует большая необходимость частой смены целых блоков конфигурации - лучше использовать `context.xml`, чтобы избежать перекомпилирования приложения.